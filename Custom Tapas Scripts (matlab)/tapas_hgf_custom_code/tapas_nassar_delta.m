function [traj, infStates] = tapas_nassar_delta(r, p, varargin)
% Calculates the trajectories of the agent's representations under the eHGF model of the jumping
% Gaussian estimation task (JGET)
%
% This function can be called in two ways:
%
% (1) tapas_ehgf_jget(r, p)
%
%     where r is the structure generated by fitModel and p is the parameter vector in native space;
%
% (2) tapas_ehgf_jget(r, ptrans, 'trans')
%
%     where r is the structure generated by fitModel, ptrans is the parameter vector in
%     transformed space, and 'trans' is a flag indicating this.
%
% --------------------------------------------------------------------------------------------------
% Copyright (C) 2013-2020 Christoph Mathys, TNU, UZH & ETHZ
%
% This file is part of the HGF toolbox, which is released under the terms of the GNU General Public
% Licence (GPL), version 3. You can redistribute it and/or modify it under the terms of the GPL
% (either version 3 or, at your option, any later version). For further details, see the file
% COPYING or <http://www.gnu.org/licenses/>.


% Transform paramaters back to their native space if needed
if ~isempty(varargin) && strcmp(varargin{1},'trans');
    p = tapas_nassar_delta_transp(r, p);
end


% Unpack parameters
vhat_0 = p(1);
N_0 = p(2);
hazExp = p(3);

% task specific 
RewRange = [1,100];
C = 0.01;
Infer_Noise = 1;
% Add dummy "zeroth" trial
% u = [0; r.u(:,1)];
u = r.u(:,1); % outcomes the subject sees
% Number of trials (not including prior)
n = length(u);

% Construct time axis
% t = ones(n,1);

% Initialize updated quantities

% Representations
vhat = NaN(n+1,1);
var = NaN(n+1,1);
R = NaN(n+1,1);
% Delta = NaN(n,l);
totSig= NaN(n,1);
sigmaU = NaN(n,1);
lr =  NaN(n,1);
lr_var =  NaN(n,1);

sigmaE = N_0;
var(1)    = sigmaE.^2;
vhat(1)   = vhat_0;
R(1)   = 1;
nCount = 0;
% expRun= .1;

NewMean = 1/(RewRange(2) -RewRange(1)); %flat uniform prior
% Representation priors
% Note: first entries of the other quantities remain
% NaN because they are undefined and are thrown away
% at the end; their presence simply leads to consistent
% trial indices.

% Representation update loop
% Pass through trials
for k = 1:1:n
    %     if not(ismember(k-1, r.ign))
    
    %%%%%%%%%%%%%%%%%%%%%%
    % Effect of input u(k)
    %%%%%%%%%%%%%%%%%%%%%%
    % reset sigmaE based on errors
    sigmaE=sqrt(var(k));
    
    % part 1 get the expected distribution
    sigmaU(k)=sqrt(((sigmaE.^2)./R(k)));         % changed things to squared and added in drift uncertainty
    R(k)=sigmaE.^2 ./sigmaU(k).^2;                       % recompute R including drift uncertainty
    totSig(k)=sqrt(sigmaE.^2+sigmaU(k).^2);             % same deal
    
    % part 2 calculate probability of change
    pI=normpdf(u(k),vhat(k),totSig(k));
    % normalize to correct for probability outside of range.  fixed
    % an error in this code on 9-25-09...
    normalize=((normcdf(RewRange(2), vhat(k), totSig(k)))- normcdf(RewRange(1), vhat(k), totSig(k)));
    pI=pI./normalize;
    clear chaRat
    likeRatio  =log(NewMean)-log(pI);  
    prioRatio  =log(hazExp)-log(1-hazExp);
    changeRatio= exp(likeRatio + prioRatio);
    chaRat = changeRatio;
    chaRat(isfinite(changeRatio))=changeRatio(isfinite(changeRatio));
    chaRat(~isfinite(changeRatio))= exp(100);
    allPCha=chaRat'./(1+chaRat');
    pCha(k)=nanmean(allPCha);
    pNoCha=1-pCha(k);
    
     % part 3 update belief about mean

    yInt  = 1./(R(k)+1);    % now R can be really small if there is a big drift...
    slope = (1-yInt);
    lr(k)  = yInt+pCha(k).*slope;
    Delta = u(k) - vhat(k);
    vhat(k+1)= vhat(k)+lr(k).*Delta;
    if isnan(vhat(k+1))
        vhat(k);
    end
        
    %  part 4 update run length   
   
        R(k+1)=(R(k)+1).*pNoCha+pCha(k);% computed by taking expected value over the run length distribution
    % part 6: update estimate of noise  (THIS SHOULD BE UNBIASED!!!)    
    
    if k >1 && (Infer_Noise == 1) 
    exVar   = (R(k)./(R(k)+1)).*(Delta.^2);
    nCount  = nCount+(1-pCha(k));   
    var(k+1) = (var(k).*(nCount-pNoCha)./nCount)       +       exVar.*pNoCha./nCount;  % this is an updated assessment of the variance
    lr_var(k) = pNoCha./nCount;
    %nCount=max([nCount-nCount./C 0]);
    
    nCount=max([0 min([nCount 1./C-1])]);
     
    else 
        var(k+1)=var(k);
        lr_var(k) = 0;
    end
    if isnan(var(k+1))
       var(k);
    end
    
end

% Remove predictions
R(n+1,:)  = [];
var(n+1,:)  = [];
vhat(n+1,:)  = [];


% Create result data structure
traj = struct;

traj.vhat     = vhat;
traj.var     = var;
traj.R     = R;
traj.lr     = lr;
traj.lr_var     = lr_var;


% Create matrices for use by the observation model
infStates  = traj.vhat;
% infStates(:,1,2)  = traj.var;
% infStates(:,1,3)  = traj.R;
% infStates(:,1,4)  = traj.lr;


end
